% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pmml_prcomp.R
\name{pmml_prcomp}
\alias{pmml_prcomp}
\title{Generate PMML for prcomp objects}
\usage{
pmml_prcomp(model, j = 1, ...)
}
\arguments{
\item{model}{A prcomp object.}

\item{j}{Index of the eigenvector for which the PMML will be created.
Per default, the PMML will be constructed based on the eigenvector of the
first principal component.}

\item{...}{Further arguments passed to \code{pmml.lm()} which make sense in
the given context}
}
\value{
An object of class XMLNode which is of type PMML.
}
\description{
Extract one principal component from a prcomp object together with the
centering and scaling information and generate the PMML representation.
}
\details{
In general, each principal component represents a linear combination of the
original input values. Therefore, the information of a single principal
component can be expressed as a linear function and as such be represented as
a linear model in PMML. \code{pmml_prcomp()} extracts one eigenvector
from a prcomp object together with the centering and scaling information if
they are present. At first, it leverages \code{FunctionXform()} from
\pkg{pmmlTransformations} to add the centering and scaling information to an
empty WrapData object. Even though this step is a kind of dirty hack, it is the
only option to capture the centering and scaling as pre-processing steps in
the PMML later. Next, a "minimal", artifical lm object is created based on
the coefficients of the selected principal component. "minimal" in the way
that all information is present which \code{pmml.lm()} from \pkg{pmml} needs
to create a valid PMML. In a final step the pre-processing steps and
the "minimal" lm object are passed to \code{pmml.lm()} to create the PMML.
}
\examples{
iris <- iris[, -5]
pc_iris <- prcomp(iris, center = FALSE, scale. = FALSE)
pmml_prcomp(pc_iris)

pc_iris <- prcomp(iris, center = TRUE, scale. = TRUE)
pmml_prcomp(pc_iris, 2)
}
