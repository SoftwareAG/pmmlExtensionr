% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pmml_prcomp.R
\name{pmml_prcomp}
\alias{pmml_prcomp}
\title{Generates PMML for prcomp objects}
\usage{
pmml_prcomp(model, n = 1, model.name = "Principal_Component_Model",
  description = "Principal Component Model")
}
\arguments{
\item{model}{A prcomp object.}

\item{n}{The number of the principal component for which the PMML will be created.
Per default, the PMML will be constructed based on the eigenvector of the
first principal component.}
}
\value{
An object of class XMLnode which is of type PMML.
}
\description{
Extracts one principal component from a prcomp object together with the
centering and scaling information and generates the PMML representation.
}
\details{
In general, each principal component represents a linear combination of the
original input values. Therefore, the information of a single principal
component can be expressed as a linear function and as such be represented as
a linear model in PMML. \code{pmml_prcomp()} extracts one eigenvector
from a prcomp object together with the centering and scaling information if
they are present. At first, it leverages \code{FunctionXform()} from
\pkg{pmmlTransformations} to add the centering and scaling information to an
empty WrapData object. Even though this step is a kind of dirty hack, it is the
only option to capture the centering and scaling as pre-processing steps in
the PMML later. Next, a "minimal", artifical lm object is created based on
the coefficients of the selected principal component. "minimal" in the way
that all information is present which \code{pmml.lm()} from \pkg{pmml} needs
to create a valid PMML. In a final step the pre-processing steps and
the "minimal" lm object are passed to \code{pmml.lm()} to create the PMML.
}
